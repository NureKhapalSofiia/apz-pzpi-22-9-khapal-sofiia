Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії









Звіт
з лабораторної роботи №2
з дисципліни «Архітектура програмного забезпечення»








Виконала:                                                                             Перевірив:
ст. гр. ПЗПІ-22-9                                                                 Дашенков Д.С.
Хапаль С.Є.

Харків 2025

Тема: Мобільний застосунок для системи по догляду за шкірою
Мета: розробити мобільний застосунок для системи по догаду за шкірою

Структура проекту:
Пакет data містить підпакети api, model, preferences і repository, які відповідають за роботу з API, зберігання моделей даних, локальні налаштування користувача та реалізацію репозиторіїв. 
Пакет di використовується для налаштування залежностей за допомогою Dependency Injection. Пакет navigation відповідає за навігацію між екранами застосунку. 
Основна логіка відображення інтерфейсу зосереджена у пакеті presentation, який містить окремі підпакети для кожного функціонального екрану: auth, chat, doctor, home, main, profile, recommendations, usedproducts, usingproducts та welcome, що забезпечує модульність і зручність у підтримці коду. 
Пакет ui містить підпакети components (повторно використовувані візуальні компоненти) та theme (налаштування кольорів і стилів), що дозволяє централізовано керувати зовнішнім виглядом застосунку. 
Нижче наведено скріншот структури екранів:


 
Рисунок 1 – Файли екранів застосунку

Усі рисунки, що були використані у застосунку зберігаються у папці „res/drawable“. Тут розміщені фото профілю, зображення для карток на головному екрані та інші.

 
Рисунок 2 – Рисунки для застосунку

	Крім того при створенні застосунку було використано шрифт «KleeOne». Він розміщений у папці «res/font».

 
Рисунок 3 – Розміщення шрифту «KleeOne» 

Приклад коду основних екранів та елементів:
-	WelcomeScreen:
Функції WelcomeScreen має анотацію @Composable, що означає, що дана функція використовується для побудови UI-компонента в декларативному стилі. У неї передається параметр onSignInClick - це лямбда-функція, яка буде викликана, коли користувач натисне на текст «Увійдіть у свій акаунт».
Всередині функції «WelcomeScreen» розміщений головний контейнер Box, котрий займає всю доступну площу екрану завдяки Modifier.fillMaxSize(). Він виступає як основа, на якій далі "будується" інтерфейс.
У першому внутрішньому Box створюється фон із вертикальним градієнтом. Він плавно переходить від світло-блакитного кольору до білого. Градієнт задається через Brush.verticalGradient із трьома точками зупинки кольору: зверху - світло-блакитний, посередині - ще світліший, і внизу - білий.
Одразу після фону додається компонент PurpleWaves. Це спеціальна анімована хвиля, яка реалізована окремо у PurpleWaves.kt. Вона накладається зверху градієнта і займає всю площу екрану (matchParentSize).
Далі йде основна інформаційна частини, що розташовується внизу екрану, бо Column має вертикальне вирівнювання Arrangement.Bottom. Тут розміщений заголовок, підзаголовок і невеликий візуальний акцент. Колонка займає весь екран по ширині й висоті, але вміст "прижатий" до нижнього краю за допомогою відступу padding(start = 24.dp, bottom = 115.dp).
Першим у колонці відображається великий текст "Welcome". Він написаний чорним кольором, з використанням стилю headlineLarge із теми Material Design.
Після нього додається трохи простору (Spacer) і йде підпис - "Увійдіть у свій акаунт". Цей текст менший, менш контрастний (чорний із прозорістю 0.9), і клікабельний. Якщо натиснути на нього, виконається дія onSignInClick(), яку ми передали у функцію.
Після цього йде ще один Spacer для відступу й внизу - коротка біла лінія з округлими краями
Нижче наведено сам код:

 
Рисунок 4 – Перша частина коду функції  «WelcomeScreen»

 
Рисунок 5 – Друга частина коду функції  «WelcomeScreen»

	Результат роботи коду:
 
Рисунок 6 – Екран «WelcomeScreen»

Фіолетова панель-хвиля:
	Функція PurpleWaves створює хвильову анімацію, яка використовується як декоративний елемент на фоні багатьох екранів застосунку Skinora. Вона реалізована за допомогою Canvas, що дозволяє вручну малювати фігури.
	Спочатку малюється задня хвиля. Для цього створюється шлях back, який починається з висоти екрану 0.58f. Далі за допомогою quadraticBezierTo створюютьсяплавні вигини, що формують хвилю. Усього тут дві квадратичні криві, які визначають форму цієї синьо-фіолетової лінії. Після завершення хвилі закриваємо фігуру по нижній частині екрана - щоб вона стала залитою. Потім виконується команда drawPath, яка відображає цю хвилю з кольором Color(0xFFD3CBFF).
Після цього створюється друга хвиля – передня. Для її створення використовується такий же алгоритм, що і для задньої.
Нижче наведено сам код хвилі:

 
Рисунок 7 –Код функції  «PurpleWaves»

	Результат роботи коду:

 
Рисунок 8 – Нижня панель-хвиля
-	Панель «Останній аналіз»
Блок створюється за допомогою компонента Box, який виконує роль обгортки. Йому задається ширина 360.dp та висота 290.dp, після чого він центрується по горизонталі на екрані. Колір фону - білий, із закругленням країв у 24.dp - це створює візуальний ефект легкості й акуратності. Команда .clip() гарантує, що всі внутрішні елементи будуть обрізані по формі, тобто нічого не вийде за межі округленого фону.
Усередині Box розташовується Column — вертикальна колонка, яка використовується для виведення рядків інформації. Вона має внутрішні відступи з усіх боків — по 24.dp по горизонталі та 20.dp зверху, а також великий нижній відступ — 80.dp, для того щоб не перекривати нижню хвилю.
Кожен елемент у цій колонці створюється через виклики InfoRow().
Фон цієї панелі додатково прикрашається заокругленою хвилею. Вона реалізована за допомогою drawPath() у Canvas-компоненті, де використовується вертикальний градієнт. Замість однотонної заливки ми задаємо плавний перехід кольорів. Для покращення контрасту та додаткового декоративного ефекту, поверх градієнта малюється ще один шлях (topPath) — цього разу з обводкою (Stroke) шириною 2.dp.

 
Рисунок 9 – Перша частина коду «Останній аналіз»
 
Рисунок 10 – Друга частина коду «Останній аналіз»

 
Рисунок 11 – Третя частина коду «Останній аналіз»

	Результат роботи коду:

 
Рисунок 12 – Блок «Останній наліз»

-	Картки списків користувача
Цей фрагмент коду відповідає за створення картки «У використанні», яка є частиною вертикального списку категорій косметичних засобів. Компонент Column організовує картки з відступами, щоб інтерфейс був охайним і легким для сприйняття.
Використовується шрифт КleeОne_regular. Картка створюється через компонент CardItem, куди передається зображення (imageName = "using"), заголовок і підзаголовок.
При натисканні на картку відбувається навігація на відповідний екран (using).

 
Рисунок 13 – Створення картки для списку «У використання»

Сomposable-функцію CardItem є шаблоном для створення картки з зображенням, заголовком, підзаголовком та дією при натисканні.
На вхід функція приймає чотири параметри: imageName (назва зображення), title (Composable-блок заголовка), subtitle (рядок підзаголовка) та onClick (дія, яка виконується при натисканні).
Головний контейнер — це Box, що займає всю ширину (fillMaxWidth) і має фоновий білий колір. Його форма задана через RoundedCornerShape, де верхні кути мають радіус 60.dp, а нижні — 20.dp. Поверхня зроблена клікабельною за допомогою виклику onClick.
Всередині Box розташовано Row — горизонтальна структура, яка центрує свій вміст по вертикалі. Тут реалізовано логіку вибору зображення на основі imageName. Залежно від значення, завантажується відповідний ресурс з drawable.
Після вибору зображення воно виводиться через компонент Image. Його розмір — 65.dp, а параметр contentScale = Fit гарантує правильне масштабування без обрізки. Далі йде Spacer на 16.dp, який відділяє зображення від текстового блоку, створюючи простів в інтерфейсі.
У правій частині Row розташовується Column, де спочатку виводиться заголовок, переданий як title, а потім — підзаголовок subtitle, оформлений сірим кольором (DarkGray) та шрифтом 14.sp.

 
Рисунок 14 – Перша частина коду функції «CardItem»
 
Рисунок 15 – Друга частина коду функції «CardItem»

	Результат роботи коду:

 
Рисунок 16 – Картки списків користувача

-	Картка продукту у одному з списків
На початку визначається кастомний шрифт kleeOne. Далі за допомогою when(product.category) визначається, яке саме зображення використовувати. Категорія продукту (наприклад, "serum", "mask", "spf") зв’язується з відповідним ресурсом у папці drawable. Якщо категорія не знайдена, за замовчуванням використовується cream.png.
Основний контейнер оформлюється через Box, який займає всю доступну ширину (fillMaxWidth) і має складну форму завдяки RoundedCornerShape. Верхні кути мають радіус 60.dp, а нижні — 20.dp. Поверхня білого кольору (Color.White) і вся картка є клікабельною — тобто при натисканні викликається функція onClick.
Вміст картки реалізований за допомогою Row, що вирівнює елементи по вертикалі. Першим елементом йде зображення продукту. Воно завантажується через painterResource, має фіксований розмір 60.dp і масштабування ContentScale.Fit для коректного відображення без обрізання.
Між зображенням і текстом додається горизонтальний відступ у 12.dp за допомогою Spacer. Поруч у Column виводиться текстова інформація про продукт. Перший Text відображає назву продукту (product.name) з напівжирним стилем (SemiBold) і кастомним шрифтом kleeOne. Другий рядок — це опис продукту (product.description), оформлений сірим кольором (DarkGray) і розміром 14.sp. Така типографіка забезпечує гарний контраст і зрозумілу ієрархію тексту.

 
Рисунок 17 – Перша частина коду функції «ProductCard»
 
Рисунок 18 – Друга частина коду функції «ProductCard»

	Результат роботи коду:

 
Рисунок 19 – Картки продуктів

-	UML діаграма прецедентів (Use Case Diagram); 

 
Рисунок 20 - UML діаграма прецедентів

Посилання на детальний перегляд діаграми:
https://lucid.app/lucidchart/14dde743-352d-455e-8313-463e352e19bb/edit?viewport_loc=4397%2C2054%2C2775%2C1363%2C0_0&invitationId=inv_98cb0e24-0072-42c1-8cfd-212c2eac483b

-	UML діаграма компонентів (Component Diagram).

 
Рисунок 21 - UML діаграма компонентів

Посилання на детальний перегляд діаграми:
https://lucid.app/lucidchart/14dde743-352d-455e-8313-463e352e19bb/edit?viewport_loc=4397%2C2054%2C2775%2C1363%2C0_0&invitationId=inv_98cb0e24-0072-42c1-8cfd-212c2eac483b

-	ER-модель даних
 
Рисунок 22 - ER-модель даних

Посилання на детальний перегляд діаграми:
https://lucid.app/lucidchart/14dde743-352d-455e-8313-463e352e19bb/edit?viewport_loc=-610%2C999%2C7200%2C3536%2C0_0&invitationId=inv_98cb0e24-0072-42c1-8cfd-212c2eac483b

-	UML діаграма станів (State Diagram).

 
Рисунок 23 - UML діаграма станів

Посилання на детальний перегляд діаграми:
https://lucid.app/lucidchart/14dde743-352d-455e-8313-463e352e19bb/edit?viewport_loc=2204%2C2190%2C4662%2C2027%2C0_0&invitationId=inv_98cb0e24-0072-42c1-8cfd-212c2eac483b

Посилання на GitHub:
https://github.com/NureKhapalSofiia/apz-pzpi-22-9-khapal-sofiia/tree/main/Lab2
Посилання на відео з демонстрацією роботи усього функціоналу:  
https://drive.google.com/drive/folders/1-fWtbwz177J2RsFhYFKuYqUsbr6Ak-ln?usp=sharing

Висновок: під час виконання даної лабораторної робити, я розробила мобільний застосунок для системи по догляду за шкірою на мові програмування Kotlin. Крім того підв’язала запланований функціонал.
